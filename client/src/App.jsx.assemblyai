import React, { useState, useRef } from 'react';
import './App.css';

function App() {
  const [file, setFile] = useState(null);
  const [transcription, setTranscription] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [language, setLanguage] = useState('en');
  const [task, setTask] = useState('transcribe');
  const [format, setFormat] = useState('txt');
  const [progress, setProgress] = useState(0);
  const [service, setService] = useState('auto');
  const [fileInfo, setFileInfo] = useState(null);
  
  const fileInputRef = useRef(null);

  const handleFileChange = (e) => {
    const selectedFile = e.target.files[0];
    if (selectedFile) {
      const fileSize = selectedFile.size;
      const fileSizeMB = (fileSize / (1024 * 1024)).toFixed(1);
      
      setFile(selectedFile);
      setFileInfo({
        name: selectedFile.name,
        size: fileSizeMB,
        type: selectedFile.type
      });
      
      // Auto-select service based on file size
      if (fileSize > 25 * 1024 * 1024) {
        setService('assemblyai');
        setError(`Large file (${fileSizeMB}MB) - will use AssemblyAI (supports up to 2GB)`);
      } else {
        setService('whisper');
        setError('');
      }
    }
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    const droppedFile = e.dataTransfer.files[0];
    if (droppedFile && droppedFile.type.startsWith('audio/') || droppedFile.type.startsWith('video/')) {
      handleFileChange({ target: { files: [droppedFile] } });
    } else {
      setError('Please drop an audio or video file');
    }
  };

  const formatDuration = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  const transcribeWithWhisper = async (file) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('language', language);
    formData.append('task', task);
    formData.append('format', format);

    const response = await fetch('/api/transcribe', {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Transcription failed');
    }

    return response.json();
  };

  const transcribeWithAssemblyAI = async (file) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('language', language);
    formData.append('format', format);

    const response = await fetch('/api/transcribe-assemblyai', {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'AssemblyAI transcription failed');
    }

    return response.json();
  };

  const handleTranscribe = async () => {
    if (!file) {
      setError('Please select a file first');
      return;
    }

    setIsLoading(true);
    setError('');
    setTranscription('');
    setProgress(0);

    try {
      let result;
      
      // Use the selected service
      if (service === 'assemblyai' || file.size > 25 * 1024 * 1024) {
        console.log('Using AssemblyAI for transcription...');
        result = await transcribeWithAssemblyAI(file);
      } else {
        console.log('Using Whisper for transcription...');
        result = await transcribeWithWhisper(file);
      }

      setTranscription(result.text || result.transcription);
      
      // Handle different response formats
      if (format === 'srt' && Array.isArray(result.text)) {
        setTranscription(result.text.map(s => `${s.index}\n${s.start} --> ${s.end}\n${s.text}`).join('\n\n'));
      } else if (format === 'vtt') {
        setTranscription(result.text || result.transcription);
      } else if (format === 'csv') {
        setTranscription(result.text || result.transcription);
      } else {
        setTranscription(result.text || result.transcription);
      }

      // Show processing info
      if (result.processing_time) {
        setFileInfo(prev => ({
          ...prev,
          processingTime: result.processing_time,
          service: result.service || service
        }));
      }

    } catch (err) {
      console.error('Transcription error:', err);
      setError(`Transcription failed: ${err.message}`);
    } finally {
      setIsLoading(false);
      setProgress(0);
    }
  };

  const handleDownload = (formatType) => {
    if (!transcription) return;

    let content = transcription;
    let filename = `transcription.${formatType}`;
    let mimeType = 'text/plain';

    switch (formatType) {
      case 'txt':
        content = transcription;
        mimeType = 'text/plain';
        break;
      case 'srt':
        content = transcription;
        mimeType = 'application/x-subrip';
        filename = 'transcription.srt';
        break;
      case 'vtt':
        content = transcription;
        mimeType = 'text/vtt';
        filename = 'transcription.vtt';
        break;
      case 'json':
        content = JSON.stringify({ transcription, metadata: fileInfo }, null, 2);
        mimeType = 'application/json';
        filename = 'transcription.json';
        break;
      case 'csv':
        content = transcription;
        mimeType = 'text/csv';
        filename = 'transcription.csv';
        break;
    }

    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="App">
      <header className="App-header">
        <h1>Advanced Audio Transcriber</h1>
        <p>Support for large files up to 2GB using AssemblyAI</p>
      </header>

      <main className="App-main">
        <div className="upload-section">
          <div 
            className="drop-zone"
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            onClick={() => fileInputRef.current.click()}
          >
            <input
              ref={fileInputRef}
              type="file"
              accept="audio/*,video/*"
              onChange={handleFileChange}
              style={{ display: 'none' }}
            />
            <div className="drop-zone-content">
              <div className="upload-icon">üìÅ</div>
              <p>Click to browse or drag & drop audio/video files</p>
              <p className="file-size-info">Supports files up to 2GB</p>
            </div>
          </div>

          {fileInfo && (
            <div className="file-info">
              <h3>File Information</h3>
              <p><strong>Name:</strong> {fileInfo.name}</p>
              <p><strong>Size:</strong> {fileInfo.size} MB</p>
              <p><strong>Service:</strong> {service === 'assemblyai' ? 'AssemblyAI (Large files)' : 'Whisper (‚â§25MB)'}</p>
              {fileInfo.processingTime && (
                <p><strong>Processing Time:</strong> {formatDuration(fileInfo.processingTime)}</p>
              )}
            </div>
          )}

          <div className="options-section">
            <div className="option-group">
              <label>Transcription Service:</label>
              <select value={service} onChange={(e) => setService(e.target.value)}>
                <option value="auto">Auto-select (recommended)</option>
                <option value="whisper">OpenAI Whisper (‚â§25MB)</option>
                <option value="assemblyai">AssemblyAI (up to 2GB)</option>
              </select>
            </div>

            <div className="option-group">
              <label>Language:</label>
              <select value={language} onChange={(e) => setLanguage(e.target.value)}>
                <option value="en">English</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese</option>
                <option value="zh">Chinese</option>
                <option value="ja">Japanese</option>
                <option value="ko">Korean</option>
                <option value="auto">Auto-detect</option>
              </select>
            </div>

            <div className="option-group">
              <label>Task:</label>
              <select value={task} onChange={(e) => setTask(e.target.value)}>
                <option value="transcribe">Transcribe</option>
                <option value="translate">Translate to English</option>
              </select>
            </div>

            <div className="option-group">
              <label>Output Format:</label>
              <select value={format} onChange={(e) => setFormat(e.target.value)}>
                <option value="txt">Plain Text</option>
                <option value="srt">SRT Subtitles</option>
                <option value="vtt">WebVTT Subtitles</option>
                <option value="json">JSON (with timestamps)</option>
                <option value="csv">CSV (with timestamps)</option>
              </select>
            </div>
          </div>

          <button 
            className="transcribe-button" 
            onClick={handleTranscribe}
            disabled={!file || isLoading}
          >
            {isLoading ? 'Processing...' : 'Start Transcription'}
          </button>

          {error && <div className="error-message">{error}</div>}

          {isLoading && (
            <div className="loading-section">
              <div className="spinner"></div>
              <p>Processing your file... This may take a few minutes for large files.</p>
              {progress > 0 && <p>Progress: {progress}%</p>}
            </div>
          )}
        </div>

        {transcription && (
          <div className="transcription-section">
            <h3>Transcription Result</h3>
            <div className="transcription-controls">
              <button onClick={() => handleDownload(format)} className="download-button">
                Download ({format.toUpperCase()})
              </button>
              <button onClick={() => navigator.clipboard.writeText(transcription)} className="copy-button">
                Copy to Clipboard
              </button>
            </div>
            <div className="transcription-content">
              <textarea 
                value={transcription} 
                readOnly 
                rows={10}
                className="transcription-text"
              />
            </div>
          </div>
        )}
      </main>
    </div>
  );
}

export default App;