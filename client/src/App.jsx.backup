import React, { useState, useRef, useEffect } from 'react'

// Utility functions for formatting timestamps
function toSRT(segs) {
  const fmt = t => {
    const ms = Math.floor(t * 1000)
    const h = Math.floor(ms / 3600000)
    const m = Math.floor((ms % 3600000) / 60000)
    const s = Math.floor((ms % 60000) / 1000)
    const ms2 = ms % 1000
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')},${String(ms2).padStart(3, '0')}`
  }
  return segs.map((s, i) => `${i + 1}\n${fmt(s.start)} --> ${fmt(s.end)}\n${s.text.trim()}\n`).join('\n')
}

function toVTT(segs) {
  const fmt = t => {
    const ms = Math.floor(t * 1000)
    const h = Math.floor(ms / 3600000)
    const m = Math.floor((ms % 3600000) / 60000)
    const s = Math.floor((ms % 60000) / 1000)
    const ms2 = ms % 1000
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}.${String(ms2).padStart(3, '0')}`
  }
  return 'WEBVTT\n\n' + segs.map(s => `${fmt(s.start)} --> ${fmt(s.end)}\n${s.text.trim()}\n`).join('\n')
}

function toCSV(segs) {
  return 'Start Time,End Time,Text\n' + segs.map(s => `"${s.start}","${s.end}","${s.text.replace(/"/g, '""')}"`).join('\n')
}

function toJSON(segs) {
  return JSON.stringify(segs, null, 2)
}

function download(name, text) {
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = name
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

// Format file size in human-readable format
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

export default function App() {
  const [file, setFile] = useState(null)
  const [status, setStatus] = useState('idle')
  const [log, setLog] = useState([])
  const [text, setText] = useState('')
  const [segs, setSegs] = useState([])
  const [language, setLanguage] = useState('en')
  const [prompt, setPrompt] = useState('') 
  const [errorDetails, setErrorDetails] = useState(null)
  const [retryCount, setRetryCount] = useState(0)
  const fileInputRef = useRef(null)
  const logContainerRef = useRef(null)

  // Constants for validation
  const MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB (OpenAI limit)
  const ALLOWED_TYPES = ['audio/', 'video/'];
  const MAX_RETRIES = 3;

  // Scroll to bottom of log when new entries are added
  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight
    }
  }, [log])

  // Handle drag and drop events
  const handleDragOver = (e) => {
    e.preventDefault()
    const container = document.querySelector('.file-upload-container')
    if (container) {
      container.classList.add('drag-over')
    }
  }

  const handleDragLeave = (e) => {
    e.preventDefault()
    const container = document.querySelector('.file-upload-container')
    if (container) {
      container.classList.remove('drag-over')
    }
  }

  const handleDrop = (e) => {
    e.preventDefault()
    const container = document.querySelector('.file-upload-container')
    if (container) {
      container.classList.remove('drag-over')
    }
    
    const files = e.dataTransfer.files
    if (files.length > 0) {
      validateAndSetFile(files[0])
    }
  }

  // Validate file before setting
  const validateAndSetFile = (selectedFile) => {
    // Reset error state
    setErrorDetails(null)
    
    // Check file type
    const isAllowedType = ALLOWED_TYPES.some(type => selectedFile.type.startsWith(type))
    if (!isAllowedType) {
      setStatus('error')
      setLog(prev => [...prev, `Error: File type "${selectedFile.type}" is not supported. Please upload an audio or video file.`])
      return
    }
    
    // Check file size
    if (selectedFile.size > MAX_FILE_SIZE) {
      setStatus('error')
      setLog(prev => [...prev, `Error: File size (${formatFileSize(selectedFile.size)}) exceeds the maximum allowed size of ${formatFileSize(MAX_FILE_SIZE)}.`])
      return
    }
    
    // File is valid
    setFile(selectedFile)
    setLog(prev => [...prev, `File selected: ${selectedFile.name} (${formatFileSize(selectedFile.size)})`])
  }

  // Transcribe function with enhanced error handling and retry logic
  async function transcribe() {
    if (!file) return
    
    setStatus('processing')
    setLog([])
    setText('')
    setSegs([])
    setErrorDetails(null)
    
    try {
      const fd = new FormData()
      fd.append("file", file)
      fd.append("model", "whisper-1")
      fd.append("language", language)
      fd.append("response_format", "verbose_json")
      
      // Add prompt if provided
      if (prompt) {
        fd.append("prompt", prompt)
      }
      
      setLog(prev => [...prev, `Uploading file: ${file.name} (${formatFileSize(file.size)})...`])
      
      const startTime = Date.now()
      const res = await fetch("/api/transcribe", {
        method: "POST",
          signal: AbortSignal.timeout(300000) // 5 minute timeout
        body: fd
      })
      const endTime = Date.now()
      const requestTime = ((endTime - startTime) / 1000).toFixed(1)
      
      if (!res.ok) {
        // Try to get more detailed error information
        let errorText = await res.text()
        let errorJson
        
        try {
          errorJson = JSON.parse(errorText)
        } catch (e) {
          // If not JSON, use text as is
          errorJson = { error: `HTTP ${res.status}: ${res.statusText}`, details: errorText }
        }
        
        throw new Error(errorJson.error || `HTTP ${res.status}: ${res.statusText}`, { 
          cause: { 
            status: res.status, 
            details: errorJson.details || errorText 
          }
        })
      }
      
      setLog(prev => [...prev, `Server response received in ${requestTime}s, processing...`])
      
      let data
      try {
        data = await res.json()
      } catch (err) {
        throw new Error(`Failed to parse server response: ${err.message}`, { 
          cause: { details: "The server returned an invalid JSON response. This might indicate a server error or timeout." } 
        })
      }
      
      if (data.error) {
        throw new Error(data.error.message || data.error, { 
          cause: { details: data.details || "No additional details provided" } 
        })
      }
      
      setText(data.text || "")
      
      // Process segments if available
      const chunks = data.segments?.map(c => ({
        start: c.start ?? 0,
        end: c.end ?? 0,
        text: c.text || ''
      })) || []
      
      setSegs(chunks)
      setStatus('done')
      setLog(prev => [...prev, `Transcription completed successfully! (${data.text?.length || 0} characters)`])
      
      // Reset retry count on success
      setRetryCount(0)
    } catch (err) {
      setStatus('error')
      
      // Extract detailed error information if available
      const errorMessage = err.message || "Unknown error occurred"
      const errorDetails = err.cause?.details || "No additional details available"
      
      setLog(prev => [...prev, `Error: ${errorMessage}`])
      setErrorDetails(errorDetails)
      console.error('Transcription error:', err)
      
      // Implement retry logic for certain errors
      if (retryCount < MAX_RETRIES && 
          (err.cause?.status === 500 || err.cause?.status === 503 || err.message.includes('timeout'))) {
        
        const nextRetry = retryCount + 1
        setRetryCount(nextRetry)
        
        const delay = Math.pow(2, nextRetry) * 1000 // Exponential backoff
        
        setLog(prev => [...prev, `Retrying in ${delay/1000} seconds... (Attempt ${nextRetry} of ${MAX_RETRIES})`])
        
        setTimeout(() => {
          setLog(prev => [...prev, `Retrying transcription...`])
          transcribe()
        }, delay)
      }
    }
  }

  const baseName = file ? file.name.replace(/\.[^/.]+$/, '') : 'transcript'
  const srt = segs.length ? toSRT(segs) : ''
  const vtt = segs.length ? toVTT(segs) : ''
  const csv = segs.length ? toCSV(segs) : ''
  const json = segs.length ? toJSON(segs) : ''

  return (
    <div className="container">
      <div className="app-container">
        <h1>Whisper Transcriber</h1>
        <p className="subtitle">Convert audio and video to text with high accuracy</p>
        
        <div className="upload-section">
          <h2 className="section-title">Upload Media</h2>
          <div 
            className="file-upload-container"
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
          >
            <div className="file-icon">üìÅ</div>
            <p className="upload-text">Drag & drop your audio or video file here</p>
            <p className="upload-hint">
              Supports MP3, WAV, MP4, MOV, AVI and other formats<br/>
              Maximum file size: {formatFileSize(MAX_FILE_SIZE)}
            </p>
            <button 
              className="upload-button" 
              onClick={() => fileInputRef.current?.click()}
            >
              Browse Files
            </button>
            <input
              type="file"
              ref={fileInputRef}
              className="file-input"
              accept="audio/*,video/*"
              onChange={e => e.target.files?.[0] && validateAndSetFile(e.target.files[0])}
            />
            {file && <p className="file-name">Selected: {file.name} ({formatFileSize(file.size)})</p>}
          </div>
        </div>
        
        <div className="options-section">
          <h2 className="section-title">Transcription Options</h2>
          <div className="options-grid">
            <div className="option-group">
              <label className="option-label">Language</label>
              <select 
                value={language} 
                onChange={e => setLanguage(e.target.value)} 
                className="option-select"
              >
                <option value="en">English</option>
                <option value="es">Spanish</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese</option>
                <option value="nl">Dutch</option>
                <option value="ru">Russian</option>
                <option value="zh">Chinese</option>
                <option value="ja">Japanese</option>
                <option value="ko">Korean</option>
              </select>
            </div>
            
            <div className="option-group">
              <label className="option-label">Custom Prompt (Optional)</label>
              <input
                type="text"
                value={prompt}
                onChange={e => setPrompt(e.target.value)}
                className="option-input"
                placeholder="Enter custom vocabulary or style guidance..."
              />
            </div>
          </div>
        </div>
        
        <div className="controls-section">
          <button 
            className="transcribe-button" 
            onClick={transcribe} 
            disabled={!file || status === 'processing'}
          >
            {status === 'processing' ? 'Processing...' : 'Transcribe'}
          </button>
        </div>
        
        <div className="status-section">
          <p className="status-text">
            Status: <span className={`status-value ${status}`}>{status}</span>
          </p>
          <div className={`spinner ${status === 'processing' ? 'active' : ''}`}></div>
          <div 
            className="progress-log" 
            ref={logContainerRef}
          >
            {log.map((l, i) => (
              <div key={i} className="log-entry">
                [{new Date().toLocaleTimeString()}] {l}
              </div>
            ))}
            
            {errorDetails && (
              <div className="error-details">
                <h4>Error Details:</h4>
                <pre>{typeof errorDetails === 'string' ? errorDetails : JSON.stringify(errorDetails, null, 2)}</pre>
              </div>
            )}
          </div>
        </div>
        
        {status === 'done' && (
          <div className="results-section active">
            <h2 className="results-title">Transcription Results</h2>
            
            <div className="download-buttons">
              <button 
                className="download-button" 
                onClick={() => download(`${baseName}.txt`, text)}
              >
                üìÑ Download .txt
              </button>
              <button 
                className="download-button" 
                onClick={() => download(`${baseName}.srt`, srt)} 
                disabled={!srt}
              >
                üé¨ Download .srt
              </button>
              <button 
                className="download-button" 
                onClick={() => download(`${baseName}.vtt`, vtt)} 
                disabled={!vtt}
              >
                üéûÔ∏è Download .vtt
              </button>
              <button 
                className="download-button" 
                onClick={() => download(`${baseName}.json`, json)} 
                disabled={!json}
              >
                üì¶ Download .json
              </button>
              <button 
                className="download-button" 
                onClick={() => download(`${baseName}.csv`, csv)} 
                disabled={!csv}
              >
                üìä Download .csv
              </button>
              <button 
                className="download-button copy-button" 
                onClick={async () => {
                  try {
                    await navigator.clipboard.writeText(text)
                    setLog(prev => [...prev, 'Transcript copied to clipboard!'])
                  } catch (err) {
                    setLog(prev => [...prev, 'Failed to copy transcript'])
                  }
                }}
              >
                üìã Copy Text
              </button>
            </div>
            
            <h3>Transcript Preview</h3>
            <textarea 
              className="transcript-preview"
              value={text} 
              readOnly 
            />
          </div>
        )}
        
        <div className="footer">
          <p>Powered by OpenAI Whisper API</p>
        </div>
      </div>
    </div>
  )
}